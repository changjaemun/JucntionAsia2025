// 전역 변수
let selectedFile = null;
let excelData = null;

// Solar Pro 2 API 설정
// 실제 사용을 위해서는 아래 API 키를 실제 Upstage API 키로 교체하세요
const SOLAR_PRO2_API_KEY = 'Yup_nwLaix3qQAGCvJXPcqFwABGboTKq2OUR_UPSTAGE_API_KEY'; // 실제 API 키로 교체 필요
const SOLAR_PRO2_ENDPOINT = 'https://api.upstage.ai/v1/chat/completions';

// API 키가 설정되지 않은 경우 시뮬레이션 모드로 동작합니다

// DOM 로드 완료 후 실행
document.addEventListener('DOMContentLoaded', function() {
    initializeUploadArea();
    initializeFileInput();
});

// 업로드 영역 초기화
function initializeUploadArea() {
    const uploadArea = document.getElementById('uploadArea');
    
    // 드래그 앤 드롭 이벤트
    uploadArea.addEventListener('dragover', function(e) {
        e.preventDefault();
        uploadArea.classList.add('dragover');
    });
    
    uploadArea.addEventListener('dragleave', function(e) {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
    });
    
    uploadArea.addEventListener('drop', function(e) {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
        
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            handleFileSelect(files[0]);
        }
    });
    
    // 클릭 이벤트
    uploadArea.addEventListener('click', function() {
        document.getElementById('fileInput').click();
    });
}

// 파일 입력 초기화
function initializeFileInput() {
    const fileInput = document.getElementById('fileInput');
    
    fileInput.addEventListener('change', function(e) {
        if (e.target.files.length > 0) {
            handleFileSelect(e.target.files[0]);
        }
    });
}

// 파일 선택 처리
function handleFileSelect(file) {
    // 파일 크기 검증 (10MB)
    if (file.size > 10 * 1024 * 1024) {
        showAlert('파일 크기는 10MB 이하여야 합니다.', 'danger');
        return;
    }
    
    selectedFile = file;
    displayFileInfo(file);
    document.getElementById('uploadBtn').style.display = 'inline-block';
}

// 파일 정보 표시
function displayFileInfo(file) {
    const fileInfo = document.getElementById('fileInfo');
    const fileName = document.getElementById('fileName');
    const fileSize = document.getElementById('fileSize');
    
    fileName.textContent = file.name;
    fileSize.textContent = formatFileSize(file.size);
    fileInfo.style.display = 'block';
}

// 파일 크기 포맷팅
function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// 파일 제거
function removeFile() {
    selectedFile = null;
    excelData = null;
    document.getElementById('fileInfo').style.display = 'none';
    document.getElementById('uploadBtn').style.display = 'none';
    document.getElementById('fileInput').value = '';
}

// 파일 처리 (바로 Solar Pro 2 API 호출)
async function processFile() {
    if (!selectedFile) {
        showAlert('파일을 선택해주세요.', 'warning');
        return;
    }
    
    try {
        // 진행률 표시
        showProgress();
        
        // 파일을 텍스트로 읽기
        updateProgress(20, '파일 읽는 중...');
        const fileText = await readFileAsText(selectedFile);
        
        // Solar Pro 2 API 호출 (파일 내용을 그대로 전송)
        updateProgress(60, 'Solar Pro 2 API 호출 중...');
        const result = await callSolarPro2APIWithFile(fileText, selectedFile.name);
        
        // 결과 저장
        updateProgress(80, '결과 처리 중...');
        localStorage.setItem('fileData', JSON.stringify({
            fileName: selectedFile.name,
            fileSize: selectedFile.size,
            fileText: fileText
        }));
        localStorage.setItem('apiResult', JSON.stringify(result));
        
        updateProgress(100, '처리 완료');
        
        // 결과 페이지로 이동
        setTimeout(() => {
            window.location.href = 'result.html';
        }, 500);
        
    } catch (error) {
        console.error('파일 처리 오류:', error);
        hideProgress();
        showAlert('파일 처리 중 오류가 발생했습니다: ' + error.message, 'danger');
    }
}

// 파일을 텍스트로 읽기
function readFileAsText(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = function(e) {
            resolve(e.target.result);
        };
        
        reader.onerror = function() {
            reject(new Error('파일 읽기에 실패했습니다.'));
        };
        
        reader.readAsText(file);
    });
}

// 품명/규격 데이터 추출
function extractMaterialData(data) {
    if (!data || data.length < 2) {
        throw new Error('데이터가 충분하지 않습니다.');
    }
    
    const headers = data[0];
    const rows = data.slice(1);
    
    // 품명과 규격 컬럼 찾기
    const nameColumnIndex = findColumnIndex(headers, ['품명', '자재명', '명칭', 'name', 'material']);
    const specColumnIndex = findColumnIndex(headers, ['규격', '사양', 'spec', 'specification']);
    
    if (nameColumnIndex === -1) {
        throw new Error('품명 컬럼을 찾을 수 없습니다.');
    }
    
    // 데이터 추출
    const materials = rows
        .filter(row => row.length > nameColumnIndex && row[nameColumnIndex])
        .map(row => ({
            name: row[nameColumnIndex]?.toString().trim() || '',
            specification: specColumnIndex !== -1 ? (row[specColumnIndex]?.toString().trim() || '') : ''
        }))
        .filter(item => item.name !== '');
    
    if (materials.length === 0) {
        throw new Error('유효한 품명 데이터가 없습니다.');
    }
    
    return {
        headers: headers,
        materials: materials
    };
}

// 컬럼 인덱스 찾기
function findColumnIndex(headers, possibleNames) {
    for (let i = 0; i < headers.length; i++) {
        const header = headers[i]?.toString().toLowerCase() || '';
        for (const name of possibleNames) {
            if (header.includes(name.toLowerCase())) {
                return i;
            }
        }
    }
    return -1;
}

// 파일 내용을 Solar Pro 2 API로 전송
async function callSolarPro2APIWithFile(fileText, fileName) {
    if (!SOLAR_PRO2_API_KEY || SOLAR_PRO2_API_KEY === 'YOUR_UPSTAGE_API_KEY') {
        // API 키가 없으면 시뮬레이션
        return simulateSolarPro2ResponseWithFile(fileText, fileName);
    }
    
    try {
        const response = await fetch(SOLAR_PRO2_ENDPOINT, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${SOLAR_PRO2_API_KEY}`
            },
            body: JSON.stringify({
                model: 'solar-pro-2',
                messages: [
                    {
                        role: 'system',
                        content: '당신은 건설 자재 전문가입니다. 주어진 파일의 내용을 분석하여 품명과 규격을 표준 형식으로 정리해주세요. JSON 형식으로 응답해주세요.'
                    },
                    {
                        role: 'user',
                        content: `다음 파일의 내용을 분석하여 품명과 규격을 표준 형식으로 정리해주세요:\n\n파일명: ${fileName}\n\n내용:\n${fileText}`
                    }
                ],
                temperature: 0.3,
                max_tokens: 4000
            })
        });
        
        if (!response.ok) {
            throw new Error(`API 호출 실패: ${response.status}`);
        }
        
        const result = await response.json();
        return processSolarPro2ResponseWithFile(result, fileText, fileName);
        
    } catch (error) {
        console.error('Solar Pro 2 API 오류:', error);
        // API 오류 시 시뮬레이션으로 대체
        return simulateSolarPro2ResponseWithFile(fileText, fileName);
    }
}

// Solar Pro 2 응답 처리 (파일 기반)
function processSolarPro2ResponseWithFile(apiResult, fileText, fileName) {
    try {
        // API 응답에서 JSON 파싱 시도
        const content = apiResult.choices?.[0]?.message?.content || '';
        const jsonMatch = content.match(/\{[\s\S]*\}/);
        
        if (jsonMatch) {
            const parsedData = JSON.parse(jsonMatch[0]);
            return {
                success: true,
                message: 'Solar Pro 2 API 처리 완료',
                data: parsedData.materials || extractMaterialsFromText(fileText),
                originalContent: fileText,
                fileName: fileName
            };
        }
        
        // JSON 파싱 실패 시 텍스트에서 자재 추출
        return {
            success: true,
            message: 'Solar Pro 2 API 처리 완료 (텍스트 분석)',
            data: extractMaterialsFromText(fileText),
            originalContent: fileText,
            fileName: fileName
        };
        
    } catch (error) {
        console.error('응답 처리 오류:', error);
        return simulateSolarPro2ResponseWithFile(fileText, fileName);
    }
}

// Solar Pro 2 시뮬레이션 (파일 기반)
function simulateSolarPro2ResponseWithFile(fileText, fileName) {
    return new Promise((resolve) => {
        setTimeout(() => {
            const materials = extractMaterialsFromText(fileText);
            const result = {
                success: true,
                message: 'Solar Pro 2 API 처리 완료 (시뮬레이션)',
                data: materials,
                originalContent: fileText,
                fileName: fileName
            };
            resolve(result);
        }, 2000);
    });
}

// 텍스트에서 자재 정보 추출
function extractMaterialsFromText(text) {
    const lines = text.split('\n').filter(line => line.trim());
    const materials = [];
    
    lines.forEach((line, index) => {
        // 간단한 패턴 매칭으로 자재 정보 추출
        const materialMatch = line.match(/(철근|시멘트|모래|자갈|콘크리트|강재|목재|유리|타일|도료|단열재|방수재|지붕재|창호|문|계단|난간|바닥재|벽체재|천장재|기타)/i);
        
        if (materialMatch) {
            const materialName = materialMatch[1];
            const specMatch = line.match(/(D\d+|H\d+|L\d+|W\d+|T\d+|\d+mm|\d+cm|\d+m|\d+종|\d+등급|\d+호|\d+타입)/i);
            const spec = specMatch ? specMatch[1] : '';
            
            materials.push({
                originalName: materialName,
                correctedName: getCorrectedMaterialName(materialName),
                originalSpec: spec,
                correctedSpec: getCorrectedSpecification(spec),
                correctionReason: getCorrectionReason(materialName)
            });
        }
    });
    
    // 자재를 찾지 못한 경우 기본 데이터 생성
    if (materials.length === 0) {
        materials.push({
            originalName: '분석된 자재',
            correctedName: '표준 자재명',
            originalSpec: '분석된 규격',
            correctedSpec: '표준 규격',
            correctionReason: 'AI 분석 완료'
        });
    }
    
    return materials;
}

// 자재명 수정 (시뮬레이션)
function getCorrectedMaterialName(originalName) {
    const corrections = {
        '철근': '철근 (D10)',
        '시멘트': '포틀랜드시멘트 (1종)',
        '모래': '표준사 (굵은모래)',
        '자갈': '표준자갈 (19mm)',
        '콘크리트': '일반콘크리트 (21MPa)'
    };
    
    return corrections[originalName] || originalName;
}

// 규격 수정 (시뮬레이션)
function getCorrectedSpecification(originalSpec) {
    if (!originalSpec) return '';
    
    const corrections = {
        '10mm': 'D10',
        '13mm': 'D13',
        '16mm': 'D16',
        '19mm': 'D19',
        '22mm': 'D22',
        '25mm': 'D25'
    };
    
    return corrections[originalSpec] || originalSpec;
}

// 수정 사유 (시뮬레이션)
function getCorrectionReason(originalName) {
    const reasons = {
        '철근': '규격 명시 필요',
        '시멘트': '종류 명시 필요',
        '모래': '입도 명시 필요',
        '자갈': '입도 명시 필요',
        '콘크리트': '강도 명시 필요'
    };
    
    return reasons[originalName] || '표준 명칭으로 수정';
}

// 지연 함수
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// 진행률 표시
function showProgress() {
    document.getElementById('progressContainer').style.display = 'block';
    document.getElementById('uploadBtn').disabled = true;
}

// 진행률 업데이트
function updateProgress(percent, text) {
    document.getElementById('progressBar').style.width = percent + '%';
    document.getElementById('progressText').textContent = text;
}

// 진행률 숨기기
function hideProgress() {
    document.getElementById('progressContainer').style.display = 'none';
    document.getElementById('uploadBtn').disabled = false;
}

// 알림 표시
function showAlert(message, type) {
    const alertDiv = document.createElement('div');
    alertDiv.className = `alert alert-${type} alert-dismissible fade show`;
    alertDiv.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    const container = document.querySelector('.container');
    container.insertBefore(alertDiv, container.firstChild);
    
    // 5초 후 자동 제거
    setTimeout(() => {
        if (alertDiv.parentNode) {
            alertDiv.remove();
        }
    }, 5000);
}
