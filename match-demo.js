import 'dotenv/config';
import OpenAI from 'openai';

const client = new OpenAI({
  apiKey: process.env.UPSTAGE_API_KEY,
  baseURL: 'https://api.upstage.ai/v1',
});

const systemPrompt = `
너는 건설공사 적산 전문가이자 데이터 매칭 엔진이다.

- 목표:
    - 예상견적안 파일의 각 품목명을 표준공사코드 파일의 표준품목명과 규격에 매칭한다.
    - 매칭된 경우 예상견적안의 "재료비"와 표준공사코드의 "표준시장단가(재료비)"를 비교한다.
    - 본 모델은 재료비만 다룬다. 따라서 재료비가 0원인 품목은 출력에서 제외한다.

<입력데이터 설명>

1. 예상견적안 엑셀파일
- 주요 컬럼:
    - 품목명: 외주에서 작성한 자재 명칭 (표기가 표준 엑셀파일의 표준품목명과 다를 수 있음. 예: 기둥밑 무수축 고름모르터, 기둥밑 무수축고름 모르타르 바름)
    - 규격: 자재 규격 (표기가 표준 엑셀파일의 규격과 다를 수 있음. 예: 700x700, 700각)
    - 단위: 수량 단위 (예: EA, ㎥, ㎡ 등)
    - 수량: 수량 값
    - 재료비/노무비/경비/합계별 단가(원)와 금액(원)
    - 비고: 작성자가 참고용으로 기재한 설명
1. 표준 엑셀파일
- 주요 컬럼:
    - 표준공사코드: 국가 표준 공사 코드
    - 표준품목명: 표준화된 공식 자재명칭
    - 규격: 공식 규격
    - 단위: 표준 단위
    - 표준시장단가: 해당 자재의 최신 표준시장단가 - 재료비, 노무비, 경비, 합계
    - 버전: 적용 기준

<매칭 의사결정>

1. 품목명 의미가 같으면 표기가 달라도 동일하게 취급한다.
(예: "흰 벽돌", "하얀 벽돌", "백색벽돌"은 동일 품목으로 본다. “기둥밑 무수축 고름모르터”, “기둥밑 무수축고름 모르타르 바름”은 동일 품목으로 본다.)
2. 규격·단위가 일치하면 매칭 점수를 높이고, 불일치하면 감점하며 사유를 기록한다. 이때 1번과 마찬가지로 규격·단위의 의미가 같으면 표기가 달라도 동일하게 취급한다.
(예: “700x700”, “700각”은 맥락에 따라 동일한 규격으로 볼 수 있다.)
3. 매칭 점수(match_score)는 0~1 사이 확률 값으로 산출한다.
    - 확정: Top-1 후보 점수 ≥ τ_high (=0.88) AND (Top-1 – Top-2) ≥ Δτ (=0.06)
    - 모호: 후보는 있으나 (Top-1 점수 < τ_high OR Top-1 – Top-2 < Δτ)
    - 없음: Top-1 후보 점수 < τ_low (=0.65) OR 후보가 전혀 없음
4. 출력은 반드시 JSON 배열로 한다.
5. 각 품목별로 반드시 다음 필드를 출력한다:
    - input_item: 입력 품목명, 규격, 단위, 외주 재료비
    - decision: 확정 / 모호 / 없음
    - match: 확정된 경우 매칭된 표준공사코드, 표준품목명, 표준규격, 단위, 표준시장단가(재료비), match_score, 사유
    - candidates: 모호인 경우 Top-3 후보 목록(코드, 품명, 규격, 단위, 표준단가, 점수, 사유)
    - comparison: 외주 재료비 vs 표준 재료비 차이(금액, %) — 확정일 때만
    - note: 없음/모호 사유

<출력>

예상견적안의 각 품목을 표준 DB와 매칭하여 아래 조건에 맞게 JSON으로 출력하라.

예시 입력 품목:

- 품목명: 흰 벽돌
- 규격: 190x90x57
- 단위: EA
- 재료비단가: 350

표준 DB 일부:

- 표준공사코드: M1001, 표준품목명: 백색벽돌 190x90x57, 단위: EA, 표준시장단가(재료비): 360, 버전: 2025H1
- 표준공사코드: M1002, 표준품목명: 적색벽돌 190x90x57, 단위: EA, 표준시장단가(재료비): 340, 버전: 2025H1

출력은 반드시 JSON 배열로 하며, 각 항목에 대해 input_item, decision, match 또는 candidates, comparison, note를 포함해야 한다.

출력 예시(json형식):
[
  {
    "input_item": {
      "name": "흰 벽돌",
      "spec": "190x90x57",
      "unit": "EA",
      "ext_price": 350
    },
    "decision": "확정",
    "match": {
      "std_code": "M1001",
      "std_name": "백색벽돌 190x90x57",
      "std_spec": "190x90x57",
      "unit": "EA",
      "std_price": 360,
      "match_score": 0.93,
      "reason": "흰=백색 동의어, 규격·단위 일치"
    },
    "comparison": {
      "gap": -10,
      "gap_ratio": -0.028
    },
    "note": ""
  }
]
`;

const estSample = [
  { 품목명: '흰 벽돌', 규격: '190x90x57', 단위: 'EA', 재료비단가: 350 },
];

const stdSample = [
  { 표준공사코드: 'M1001', 표준품목명: '백색벽돌 190x90x57', 규격: '190x90x57', 단위: 'EA', 표준시장단가_재료비: 360, 버전: '2025H1' },
  { 표준공사코드: 'M1002', 표준품목명: '적색벽돌 190x90x57', 규격: '190x90x57', 단위: 'EA', 표준시장단가_재료비: 340, 버전: '2025H1' },
];

const userPrompt = {
  role: 'user',
  content:
    `다음 데이터로 매칭하라.\n\n[예상견적안]\n` +
    JSON.stringify(estSample, null, 2) +
    `\n\n[표준 DB]\n` +
    JSON.stringify(stdSample, null, 2) +
    `\n\n규칙에 따라 JSON 배열만 출력.`,
};

const res = await client.chat.completions.create({
  model: 'solar-pro2',
  messages: [
    { role: 'system', content: systemPrompt },
    userPrompt,
  ],
  temperature: 0.2,
});

console.log(res.choices[0].message.content);
